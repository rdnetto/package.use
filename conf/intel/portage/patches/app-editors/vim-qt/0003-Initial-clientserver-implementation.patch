From cbc50f21cb6b9209fc2fc6b700930e9fc97a59ab Mon Sep 17 00:00:00 2001
From: Rui Abreu Ferreira <raf-ep@gmx.com>
Date: Thu, 18 Aug 2011 12:22:25 +0100
Subject: [PATCH 03/11] Initial clientserver implementation

- This implements client server over sockets using QDataStream,
  the protocol is rather simplistic:
  + Requests are a string followed by a bool
  + Replies are just a single string
---
 src/Makefile             |   9 +++-
 src/qt/commandserver.cpp |  62 +++++++++++++++++++++++++
 src/qt/commandserver.h   |  30 ++++++++++++
 src/qt/if_qtcmdsrv.cpp   | 117 ++++++++++++++++++++++++++++++++++++++++-------
 src/qt/vimwrapper.cpp    |  11 +++++
 src/qt/vimwrapper.h      |   1 +
 6 files changed, 212 insertions(+), 18 deletions(-)
 create mode 100644 src/qt/commandserver.cpp
 create mode 100644 src/qt/commandserver.h

diff --git a/src/Makefile b/src/Makefile
index 91f4ff9..4af5c83 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1253,6 +1253,7 @@ NEXTAW_BUNDLE	=
 # - QT_INCPATH
 MOC		= $(QT_MOC)
 QT_LIBS1	= $(QT_LIBS)
+QT_LIBS1	= -L$(QT_LIBDIR) -lQtGui -lQtCore -lQtNetwork -lstdc++
 QT_SRC	= gui.c gui_qt.cpp pty.c gui_beval.c \
 			qt/qvimshell.cpp qt/mainwindow.cpp qt/vimaction.cpp qt/scrollarea.cpp \
 			qt/fontdialog.cpp \
@@ -1260,17 +1261,19 @@ QT_SRC	= gui.c gui_qt.cpp pty.c gui_beval.c \
 			qt/if_qtcmdsrv.cpp \
 			qt/vimwrapper.cpp qt/tabbar.cpp qt/vimscrollbar.cpp \
 			qt/vimevents.cpp
+			qt/if_commandserver.cpp \
+			qt/vimwrapper.cpp qt/tabbar.cpp qt/vimscrollbar.cpp
 
 QT_OBJ	= objects/gui.o objects/gui_qt.o \
 			objects/pty.o objects/gui_beval.o \
 			objects/mainwindow.o objects/qvimshell.o objects/vimaction.o objects/qtresources.o \
 			objects/colortable.o \
 			objects/if_qtcmdsrv.o \
+			objects/commandserver.o \
 			objects/scrollarea.o objects/fontdialog.o objects/vimwrapper.o \
 			objects/vimevents.o \
 			objects/tabbar.o objects/vimscrollbar.o
 
-
 QT_DEFS	= -DFEAT_GUI_QT $(NARROW_PROTO) -Iqt -I. $(QT_INCPATH)
 QT_IPATH	= $(GUI_INC_LOC)
 QT_LIBS_DIR = $(GUI_LIB_LOC)
@@ -2637,6 +2640,10 @@ objects/tabbar.o: qt/tabbar.cpp
 objects/if_qtcmdsrv.o: qt/if_qtcmdsrv.cpp
 	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/if_qtcmdsrv.cpp
 
+objects/commandserver.o: qt/commandserver.cpp
+	$(MOC) qt/commandserver.h > commandserver.moc
+	$(CXX) $(ALL_CFLAGS) -o $@ -c qt/commandserver.cpp
+
 objects/gui_beval.o: gui_beval.c
 	$(CCC) -o $@ gui_beval.c
 
diff --git a/src/qt/commandserver.cpp b/src/qt/commandserver.cpp
new file mode 100644
index 0000000..1008e95
--- /dev/null
+++ b/src/qt/commandserver.cpp
@@ -0,0 +1,62 @@
+#include "commandserver.moc"
+#include "vimwrapper.h"
+
+extern "C" {
+#include "vim.h"
+}
+
+CommandClient::CommandClient(QLocalSocket *sock, QObject *parent)
+:QObject(parent), m_socket(sock)
+{
+	connect(m_socket, SIGNAL(disconnected()),
+		m_socket, SLOT(deleteLater()));
+
+	stream = new QDataStream(m_socket);
+	stream->setVersion(QDataStream::Qt_4_0);
+
+	connect(m_socket, SIGNAL(readyRead()),
+			this, SLOT(readRequest()));
+}
+
+void CommandClient::readRequest()
+{
+	bool asExpr;
+	QString cmd;
+
+	*stream >> cmd >> asExpr;
+	qDebug() << __func__ << cmd << asExpr;
+
+	if ( cmd.isEmpty() ) {
+		return;
+	}
+
+	if ( asExpr ) {
+		char_u *res = eval_client_expr_to_string( (char_u *)VimWrapper::convertTo(cmd).constData() );
+		*stream << VimWrapper::convertFrom((char*)res);
+	} else {
+		// Dow we need to poke the loop ?
+		server_to_input_buf((char_u *)VimWrapper::convertTo(cmd).constData());
+	}
+
+	m_socket->disconnectFromServer();
+}
+
+CommandServer::CommandServer(QObject *parent)
+:QLocalServer(parent)
+{
+	connect(this, SIGNAL(newConnection()),
+			this, SLOT(handleRequest()));
+
+}
+
+
+void CommandServer::handleRequest()
+{
+	QLocalSocket *clientConnection = nextPendingConnection();
+	if ( !clientConnection ) {
+		return;
+	}
+	CommandClient *cli = new CommandClient(clientConnection, this);
+
+
+}
diff --git a/src/qt/commandserver.h b/src/qt/commandserver.h
new file mode 100644
index 0000000..3b8a7a3
--- /dev/null
+++ b/src/qt/commandserver.h
@@ -0,0 +1,30 @@
+#ifndef __VIM_QT_COMMANDSERVER__
+#define __VIM_QT_COMMANDSERVER__
+
+#include <Qt/QtNetwork>
+
+class CommandClient: public QObject
+{
+	Q_OBJECT
+public:
+	CommandClient(QLocalSocket *, QObject *parent=0);
+
+protected slots:
+	void readRequest();
+private:
+	QLocalSocket *m_socket;
+	QDataStream *stream;
+};
+
+class CommandServer: public QLocalServer
+{
+	Q_OBJECT
+public:
+	CommandServer(QObject *parent=0);
+
+protected slots:
+	void handleRequest();
+
+};
+
+#endif
diff --git a/src/qt/if_qtcmdsrv.cpp b/src/qt/if_qtcmdsrv.cpp
index f1b31d7..5a9376d 100644
--- a/src/qt/if_qtcmdsrv.cpp
+++ b/src/qt/if_qtcmdsrv.cpp
@@ -1,13 +1,43 @@
 /*
- *
  * if_qtcmdsrv.c: Functions for passing commands through via Qt IPC.
+ *
+ * This serializes Qt types over a set of local sockets 
+ *
+ * The API we use here is mostly compatible with the WIN32 API however the
+ * protocol is not the same.
+ * @see os_mswin.c
+ *
+ *
+ *
  */
 #include <Qt/QtCore>
+#include <Qt/QtNetwork>
+#include "commandserver.h"
+#include "vimwrapper.h"
 
 extern "C" {
 
 #include "vim.h"
 
+static CommandServer serverSocket;
+
+static QString socketFolder() 
+{
+	char *env = getenv("USER");
+	if (!env) {
+		env = getenv("USERNAME");
+	}
+
+	if ( !env ) {
+		return "";
+	}
+
+	QString folderName = QString("vim-qt-%1").arg(env);
+	QDir tmp = QDir::temp();
+	tmp.mkpath(folderName);
+	return tmp.filePath(folderName);
+}
+
 /*
  * @return a newline separated list in allocated memory or NULL.
  *
@@ -18,17 +48,7 @@ serverGetVimNames(void)
 {
 	qDebug() <<__func__;
 
-	char *env = getenv("USER");
-	if (!env) {
-		env = getenv("USERNAME");
-	}
-
-	if ( !env ) {
-		return NULL;
-	}
-
-	QString foldername = QString("vim-qt-%1").arg(env);
-	QDir dir = QDir::temp().filePath(foldername);
+	QDir dir(socketFolder());
 	dir.setFilter(QDir::Files | QDir::NoDotAndDotDot );
 
 	if ( !dir.exists() ) {
@@ -57,7 +77,7 @@ serverGetVimNames(void)
  * Send a reply string (notification) to client with id "name".
  * Return -1 if the window is invalid.
  *
- * @parma name Where to send
+ * @param name Where to send
  * @param reply What to send
  */
 int
@@ -84,19 +104,61 @@ serverGetReply(HWND server, int *expr_res, int remove, int wait)
 
 /**
  *
+ * Send command to VIM server
+ *
  * @param name Where to send
  * @param cmd What to send
  * @param result Result of eval'ed expression
  * @param ptarget HWND of server
  * @param asExpr Expression or keys?
  * @param silent don't complain about no server
+ *
+ * @return 0 on success
  */
 int
 serverSendToVim(char_u *name, char_u *cmd, char **result, void *ptarget, int asExpr, int silent)
 {
-	qDebug() << (char*)name << (char*)cmd;
+	QDir dir( socketFolder() );
+	QString remotecmd = VimWrapper::convertFrom((char *)cmd);
 
-	return -1;
+	QLocalSocket sock;
+	sock.connectToServer(dir.filePath((char*)name));
+	if ( !sock.waitForConnected(3) ) {
+		return -1;
+	}
+
+	QDataStream stream(&sock);
+	stream.setVersion(QDataStream::Qt_4_0);
+
+	//
+	// Be carefull, the (bool) cast is absolutely necessary
+	// otherwise the stream alway read as false.
+	stream << remotecmd << (bool)asExpr;
+	if ( !sock.waitForBytesWritten() ) {
+		sock.close();
+		qDebug() << "write";
+		return -1;
+	}
+
+	if ( asExpr != TRUE ) {
+		return 0;
+	}
+
+	// Get reply
+	if ( !sock.waitForReadyRead() ) {
+		qDebug() << "read" << sock.error();
+
+		sock.close();
+		return -1;
+	}
+
+	QString exp_result;
+	stream >> exp_result;
+	qDebug() << exp_result;
+	*result = (char*)VimWrapper::copy(VimWrapper::convertTo(exp_result));
+
+	sock.close();
+	return 0;
 }
 
 void
@@ -104,6 +166,28 @@ serverSetName(char_u *name)
 {
 	qDebug() << __func__ << (char*)name;
 
+	QDir dir(socketFolder());
+	QFileInfo fi(dir.filePath((char*)name));
+	QString socketName = fi.absoluteFilePath();
+
+	if ( fi.exists() ) {
+		QUuid uuid = QUuid::createUuid();
+		socketName = QString((char*)name) + uuid.toString();
+	}
+	QByteArray data = socketName.toAscii();
+
+	char_u *buffer = alloc(data.length());
+	for (int i=0; i< data.length(); i++) {
+		buffer[i] = data.constData()[i];
+	}
+	serverName = buffer;
+
+	serverSocket.listen(socketName);
+
+#ifdef FEAT_EVAL
+	/* Set the servername variable */
+	set_vim_var_string(VV_SEND_SERVER, serverName, -1);
+#endif
 }
 
 /*
@@ -113,8 +197,7 @@ serverSetName(char_u *name)
 void
 serverInitMessaging(void)
 {
-	qDebug() << __func__;
-
+	// Nothing to do	
 }
 
 
diff --git a/src/qt/vimwrapper.cpp b/src/qt/vimwrapper.cpp
index 12196d8..d09b61e 100644
--- a/src/qt/vimwrapper.cpp
+++ b/src/qt/vimwrapper.cpp
@@ -433,3 +433,14 @@ bool VimWrapper::hasPendingEvents()
 	return pendingEvents.size() != 0;
 }
 
+char_u* VimWrapper::copy(const QByteArray& b)
+{
+	if ( b.length() == 0 ) {
+		return NULL;
+	}
+	char_u *buffer = alloc(b.length());
+
+	memcpy(buffer, b.constData(), b.length());
+	return buffer;
+}
+
diff --git a/src/qt/vimwrapper.h b/src/qt/vimwrapper.h
index e576077..a6aa0a2 100644
--- a/src/qt/vimwrapper.h
+++ b/src/qt/vimwrapper.h
@@ -78,6 +78,7 @@ public:
 	static QString convertFrom(const char_u *, int size=-1);
 	static QString convertFrom(const QByteArray&);
 
+	static char_u* copy(const QByteArray&);
 
 	/**
 	 * Vim methods
-- 
2.3.1

